# GraphQL Federation

This document describes the GraphQL Federation setup and contracts for the NeoTool platform.

## Overview

The GraphQL Federation implementation allows multiple services to contribute to a unified GraphQL schema while maintaining service boundaries and enabling independent development.

## Directory Structure

```
contracts/graphql/
├── shared/                    # Shared GraphQL types and utilities
├── subgraphs/                # Individual service schemas
│   └── app/                 # Main application subgraph
│       └── schema.graphqls  # Application schema definition
├── supergraph/              # Federation configuration
│   ├── supergraph.yaml     # Federation configuration
│   ├── supergraph.graphql  # Generated supergraph schema
│   ├── supergraph.dev.graphql # Development supergraph schema
│   └── scripts/            # Federation management scripts
└── sync-schemas.sh         # Schema synchronization script
```

## Federation Architecture

The platform uses Apollo Federation v2 to compose multiple GraphQL services into a single unified API:

- **Gateway Service**: Routes queries to appropriate subgraphs
- **Subgraphs**: Individual services that own specific domain data
- **Supergraph**: Composed schema that combines all subgraphs

## Service Boundaries

### Customer Service
- **Owns**: Customer data, customer management
- **Schema**: `contracts/graphql/subgraphs/customer/schema.graphqls`
- **Endpoints**: Customer CRUD operations

### Product Service  
- **Owns**: Product catalog, inventory management
- **Schema**: `contracts/graphql/subgraphs/product/schema.graphqls`
- **Endpoints**: Product CRUD operations

### Analytics Service
- **Owns**: Dashboard data, reporting, metrics
- **Schema**: `contracts/graphql/subgraphs/analytics/schema.graphqls`
- **Endpoints**: Dashboard summaries, timeseries data

## Schema Composition

The supergraph schema is automatically generated by combining all subgraph schemas using Apollo Federation composition.

### Key Federation Directives

- `@key(fields: "id")`: Defines entity keys for federation
- `@external`: Marks fields as external (defined in other subgraphs)
- `@requires(fields: "field1 field2")`: Specifies required fields from other subgraphs
- `@provides(fields: "field1 field2")`: Specifies fields this subgraph provides

## Development Workflow

### 1. Schema Development
1. Define schema in individual subgraph files
2. Use federation directives to mark entity boundaries
3. Test schema composition locally

### 2. Schema Composition
```bash
# Generate supergraph schema
./contracts/graphql/supergraph/scripts/generate-schema.sh

# Test supergraph composition
./contracts/graphql/supergraph/scripts/test-supergraph.sh
```

### 3. Schema Synchronization
```bash
# Sync schemas across services
./contracts/graphql/sync-schemas.sh
```

## Best Practices

### Schema Design
- Use clear entity boundaries
- Minimize cross-service dependencies
- Design for independent service evolution
- Use consistent naming conventions

### Federation Directives
- Always define `@key` for entities
- Use `@external` for fields defined elsewhere
- Minimize use of `@requires` for performance
- Use `@provides` to share data efficiently

### Service Independence
- Each service owns its domain data
- Services can evolve independently
- Use federation for data composition, not tight coupling
- Design for eventual consistency

## Testing

### Local Testing
- Use Apollo Studio for schema testing
- Test individual subgraphs in isolation
- Validate supergraph composition
- Test federation queries end-to-end

### Integration Testing
- Test cross-service queries
- Validate entity resolution
- Test error handling and fallbacks
- Performance testing with federation overhead

## Monitoring and Observability

- **Query Tracing**: Track queries across subgraphs
- **Performance Metrics**: Monitor federation overhead
- **Error Tracking**: Track subgraph failures and fallbacks
- **Schema Changes**: Monitor schema evolution and breaking changes

## Deployment

### Development
- Local Docker Compose setup
- Individual service development
- Schema composition testing

### Production
- Kubernetes deployment
- GitOps with ArgoCD
- Schema registry integration
- Automated schema validation

## Troubleshooting

### Common Issues
1. **Schema Composition Failures**: Check federation directives
2. **Entity Resolution Errors**: Verify `@key` definitions
3. **Performance Issues**: Optimize `@requires` usage
4. **Breaking Changes**: Use schema versioning

### Debug Tools
- Apollo Studio Explorer
- Federation composition logs
- Query execution traces
- Schema validation tools

## Resources

- [Apollo Federation Documentation](https://www.apollographql.com/docs/federation/)
- [Federation Best Practices](https://www.apollographql.com/docs/federation/best-practices/)
- [Schema Composition Guide](https://www.apollographql.com/docs/federation/quickstart/)
